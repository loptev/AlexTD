<% content_for :title, "Tower Defense | Home" %>
<div class="row">
	<div class="large-9 columns">
		<h1>Tower Defense Game</h1>
		<div id="gamescreen">
		</div>
	</div>

	<div class="large-3 columns">
		<h2 style="text-align:center">High Scores</h2>
		<table style="margin-bottom:0">
			<tr>
				<th style = "width:200px">Username</th>
				<th style = "width:100px">High Score</th>
			</tr>
		</table>
		<table id="scoreboard">
			<% @highscores.each do |user| %>
			<tr><td style = "width:200px"><%= user.username %></td><td style = "width:100px"><%= user.highscore %></td></tr>
			<% end %>
		</table>
	</div>
</div>
<% content_for :js do %>
<%= javascript_include_tag "phaser.min.js" %>
<script type="text/javascript">
	var level_data,
		tile, 
		map, 
		layer, marker, placable,
		currently_dragging, being_dragged, 
		// Groups
		detectors, paths, enemies, towers,
		enemystack = [], 
		counter = 100,
		startwave, startwavebutton, wave = 0;
	var Game = {};

	Game.Preload = function(game){};
	Game.Preload.prototype = {
		preload: function() {
			game.load.spritesheet('startwavebutton', '<%= asset_path('startwave_button.png') %>', 158, 30);
			game.load.tilemap('desert', '<%= asset_path('tilemap.json') %>', null, Phaser.Tilemap.TILED_JSON);
    		game.load.image('tile_image', '<%= asset_path('desert_tiles_small.png') %>');
			game.physics.startSystem(Phaser.Physics.ARCADE);
			game.load.spritesheet('playbutton', '<%= asset_path('PlayButton.png') %>', 158, 30);
			game.load.image('titleback', '<%= asset_path('titlebackground.png') %>');
			game.load.image('lvlselectback', '<%= asset_path('levelselect.png') %>');
			game.load.image('detector', '<%= asset_path('detector.png') %>');
			game.load.image('background', '<%= asset_path('grass1.jpg') %>');
			game.load.image('badguy1', '<%= asset_path('badguy1.png') %>');
			game.load.image('badguy2', '<%= asset_path('badguy2.png') %>');
			game.load.image('badguy3', '<%= asset_path('badguy3.png') %>');
			game.load.spritesheet('tower1', '<%= asset_path('towerspritesheet1.png') %>', 56, 56, 8);
			game.load.spritesheet('tower2', '<%= asset_path('towerspritesheet2.png') %>', 56, 56, 8);
			game.load.spritesheet('tower3', '<%= asset_path('towerspritesheet3.png') %>', 56, 56, 8);
		},
		create: function() {
			console.log("Preload State Started");
			game.state.start('Titlescreen');
		}
	};
	Game.Titlescreen = function(game) {};
	Game.Titlescreen.prototype = {
		create: function() {
			console.log("Titlescreen State Started");
			game.add.sprite(0, 0, 'titleback');
			game.add.button(game.world.centerX - 79, game.world.centerY - 90, 'playbutton', function() { 
				game.state.start('ActualGame', true, false, 1); 
			}, this, 0, 1, 2);
		}
	};
	Game.Lvlselect = function(game) {};
	Game.Lvlselect.prototype = {
		create: function() {
			console.log("Lvlselect State Started");
			this.game.add.sprite(0, 0, 'lvlselectback');
		}
	};	
	Game.ActualGame = function(game) {
		this.level;
	};
	Game.ActualGame.prototype = {
		init: function (level) {
			console.log("ActualGame State Started");
			this.level = level;
			currently_dragging = false;
		},
		create: function() {
			// Create Background and Map
			game.add.sprite(0, 0, 'background');
			map = game.add.tilemap('desert');
			map.addTilesetImage('Desert', 'tile_image');
			layer = map.createLayer('Ground');
			layer.resizeWorld();
			paths = game.add.group();
			
			// Create Detectors
			detectors = game.add.group();
			detectors.enableBody = true;
			map.createFromObjects('detectors', 1, 'detector', 0, true, false, detectors);

			map.setTileIndexCallback([1,2,3,9,10,11,17,18,19,20,21,28,29],isPlacable, this);

			enemies = game.add.group();
			towers = game.add.group();
			game.physics.enable(towers, Phaser.Physics.ARCADE);
			startwavebutton = game.add.button(10, 80, 'startwavebutton', function() { 
				startwave = true;
				buildwave(wave); 
				wave++;
				startwavebutton.visible = false;
			}, this, 0, 1, 2);
			addUI();
			setuplvl(this.level);
		},
		update: function() {
			game.physics.arcade.collide(towers, layer);
			if (currently_dragging) {
				being_dragged.reset(game.input.x-being_dragged.center.x, game.input.y-being_dragged.center.y);
				marker.x = game.input.x-being_dragged.baseWidth/2+2.5;
			    marker.y = game.input.y-being_dragged.baseHeight/2+4;
			}
			game.physics.arcade.overlap(enemies, detectors, isEnemyInCenter, null, this);
			if (startwave) {
				if (enemystack.length > 0) {
					if (counter >= 100) {
						var enemy = enemystack.shift();
						enemy = Enemy(parseInt(level_data.spawnlocation.x), parseInt(level_data.spawnlocation.y), parseInt(enemy));
						enemy.body.velocity.x = enemy.speed;
						enemy.direction = level_data.startdirection;
						counter = 0;
					}
					counter++;
				} else {
					startwavebutton.visible = true;
					startwave = false;
				}
			}
		}
	};
	function setuplvl(lvl) {
		$.getJSON('<%= asset_path('levels.json') %>', function(data) {
			level_data = data[lvl];
			// console.log(level_data);
		});
	}

	function buildwave(wave) {
		for (var i = 0; i < level_data.enemies.waves[wave].length; i++) {
			enemystack[i] = level_data.enemies.waves[wave][i];
		}
	}	

	function addUI(){
		var tower1 = Tower(10, 10, 'tower1');
		tower1.inputEnabled = true;
		tower1.events.onInputDown.add(copyAndDragTower, this);
		var tower2 = Tower(70, 10, 'tower2');
		tower2.inputEnabled = true;
		tower2.events.onInputDown.add(copyAndDragTower, this);
		var tower3 = Tower(130, 10, 'tower3');
		tower3.inputEnabled = true;
		tower3.events.onInputDown.add(copyAndDragTower, this);

	}
	function isEnemyInCenter(enemy, detector) {
		if (enemy.direction == "left" && typeof detector["left"] !== "undefined") {
			if (enemy.body.center.x < detector.body.center.x) {
				changeDir(enemy, detector);
			}
		}
		else if (enemy.direction == "right" && typeof detector["right"] !== "undefined") {
			if (enemy.body.center.x > detector.body.center.x) {
				changeDir(enemy, detector);
			}
		}
		else if (enemy.direction == "up" && typeof detector["up"] !== "undefined") {
			if (enemy.body.center.y < detector.body.center.y) {
				changeDir(enemy, detector);
			}
		}
		else if (enemy.direction == "down" && typeof detector["down"] !== "undefined") {
			if (enemy.body.center.y > detector.body.center.y) {
				changeDir(enemy, detector);
			}
		}		
	}
	function changeDir(enemy, detector) {
		switch(detector[enemy.direction]) {
			case "right":
				enemy.direction = "right";
				enemy.reset(detector.body.center.x-(enemy.body.width/2), detector.body.center.y-(enemy.body.height/2));
				enemy.body.velocity.x = 0+enemy.speed;
				enemy.body.velocity.y = 0;
				break;
			case "left":
				enemy.direction = "left";
				enemy.reset(detector.body.center.x-(enemy.body.width/2), detector.body.center.y-(enemy.body.height/2));
				enemy.body.velocity.x = 0-enemy.speed;
				enemy.body.velocity.y = 0;
				break;
			case "down":
				enemy.direction = "down";
				enemy.reset(detector.body.center.x-(enemy.body.width/2), detector.body.center.y-(enemy.body.height/2));
				enemy.body.velocity.x = 0;
				enemy.body.velocity.y = 0+enemy.speed;
				break;
			case "up":
				enemy.direction = "up";
				enemy.reset(detector.body.center.x-(enemy.body.width/2), detector.body.center.y-(enemy.body.height/2));
				enemy.body.velocity.x = 0;
				enemy.body.velocity.y = 0-enemy.speed;
				break;
		}
	}
	function copyAndDragTower(tower){
		if (!currently_dragging){
			var t = Tower(tower.x, tower.y, tower.key);
			currently_dragging = true;
			being_dragged = t;
			marker = game.add.graphics();
		    marker.beginFill(0x0BFF0B, 0.3);
		    marker.drawRect(0, 0, t.baseWidth, t.baseHeight);
			game.input.onDown.add(function(){
				if (placable==true && (game.input.x>190 || game.input.y>80)) {
					if (game.input.mouse.event.button == 2) {
						game.input.mouse.event.preventDefault();
		    			being_dragged.destroy();
		    		};
					marker.destroy();
					currently_dragging=false;
					game.input.onDown.removeAll();				
				}
			}, this);
		}
	}
	function isPlacable(s, t) {
		placable = true;
		tile = t;
		switch(t.index) {
			case 1: 
				if (((marker.x + s.baseWidth)>(t.worldX+14)) && ((marker.y + s.baseHeight)>(t.worldY+14))){
					placable = false;
				};
				break;
			case 2: 
				if ((marker.x + s.baseWidth) > (t.worldX+14)){
					placable = false;
				};
				break;
			case 3: 
				if ((marker.x < (t.worldX+14)) && ((marker.y + s.baseHeight) > (t.worldY+14))) {
					placable = false;
				};
				break;
			case 9: 
				// console.log("Right of marker: "+(marker.x + being_dragged.baseWidth));
				// console.log("Left of wall: "+(t.worldX+14));
				if ((marker.x + s.baseWidth) >= (t.worldX+14)){
					placable = false;
				};
				break;
			case 10: 
				placable = false;
				break;
			case 11: 
				if (marker.x < (t.worldX+14)){
					placable = false;
				};
				break;
			case 17: 
				if (((marker.x + s.baseWidth) > (t.worldX+14)) && (marker.y < (t.worldY+14))) {
					placable = false;
				};
				break;
			case 18: 
				if (marker.y < (t.worldY+14)) {
					placable = false;
				};
				break;
			case 19: 
				if ((marker.x < (t.worldX+14)) && (marker.y < (t.worldY+14))) {
					placable = false;
				};
				break;
			case 20: 
				if ((marker.x < (t.worldX+14)) || (marker.y < (t.worldY+14))) {
					placable = false;
				};
				break;
			case 21: 
				if (((marker.x + s.baseWidth) > (t.worldX+14)) || (marker.y < (t.worldY+14))) {
					placable = false;
				};
				break;
			case 28: 
				if ((marker.x < (t.worldX+14)) || ((marker.y + s.baseHeight) > (t.worldY+14))) {
					placable = false;
				};
				break;
			case 29: 
				if (((marker.x + s.baseWidth) > (t.worldX+14)) || ((marker.y + s.baseHeight) > (t.worldY+14))) {
					placable = false;
				};
				break;
		};
		// var newRect = game.add.graphics();		
		if (placable==true){
			console.log("Green");
		    // newRect.beginFill(0x0BFF0B, 0.3)
		} else {			
			console.log("Red");
			// newRect.beginFill(0xFF0000, 0.3);
		}
	 //    newRect.drawRect(marker.x, marker.y, being_dragged.baseWidth, being_dragged.baseHeight);
		// marker.destroy();
		// marker = newRect;
	}
	var Tower = function(x, y, key) {
		var tower;
		switch(key) {
			case 'tower1': 
				tower = this.game.add.sprite(x, y, key);
				tower.speed = 0.6;
				tower.range = 300;
				tower.doesDamage = 0.7;
				tower.center = { "x": 28, "y": 35 };
				tower.baseHeight = 33;
				tower.baseWidth = 37;
				break;
			case 'tower2': 
				tower = this.game.add.sprite(x, y, key);
				tower.speed = 0.9;
				tower.range = 150;
				tower.doesDamage = 0.6;
				tower.center = { "x": 27, "y": 35 };
				tower.baseHeight = 24;
				tower.baseWidth = 25;
				break;
			case 'tower3': 
				tower = this.game.add.sprite(x, y, key);
				tower.speed = 0.5;
				tower.range = 600;
				tower.doesDamage = 1;
				tower.center = { "x": 26, "y": 35 };
				tower.baseHeight = 29;
				tower.baseWidth = 36;
				break;
			}
		game.physics.enable(tower, Phaser.Physics.ARCADE);
		towers.add(tower);
		return tower;		
	}

	var Path = function(x, y, type) {
		var path;
		switch(type) {
			case 1: path = this.game.add.sprite(x, y, 'corner1');
				break;
			case 2: path = this.game.add.sprite(x, y, 'corner2');
				break;
			case 3: path = this.game.add.sprite(x, y, 'corner3');
				break;
			case 4: path = this.game.add.sprite(x, y, 'corner4');
				break;
			case 5: path = this.game.add.sprite(x, y, 'horizontal');
				break;
			case 6: path = this.game.add.sprite(x, y, 'vertical');		
				break;	
		}
		if (type < 5) {
			Detector(x, y, type);
		}
		game.physics.enable(path, Phaser.Physics.ARCADE);
		path.body.immovable = true;
		paths.add(path);
		return path;
	}

	var Detector = function(x, y, type) {
		var detector = this.game.add.sprite(x+19, y+19, 'detector');
		switch(type) {
			case 1: detector["right"] = "up";
					detector["down"] = "left";
				break;
			case 2: detector["left"] = "up";
					detector["down"] = "right";
				break;
			case 3: detector["up"] = "right";
					detector["left"] = "up";
				break;
			case 4: detector["right"] = "down";
					detector["up"] = "left";
				break;
		}
		detector.visible = false;
		game.physics.enable(detector, Phaser.Physics.ARCADE);
		detectors.add(detector);
	}

	var Enemy = function(centerx, centery, type) {
		var enemy;
		switch(type) {
			case 1: enemy = this.game.add.sprite(centerx, centery, 'badguy1');
				enemy.speed = 75;
				break;
			case 2: enemy = this.game.add.sprite(centerx, centery, 'badguy2');
				enemy.speed = 100;
				break;
			case 3: enemy = this.game.add.sprite(centerx, centery, 'badguy3');
				enemy.speed = 50;
				break;
		}
		enemy.direction = null;
		game.physics.enable(enemy, Phaser.Physics.ARCADE);
		enemies.add(enemy);
		return enemy;
	}
	var game = new Phaser.Game(800, 600, Phaser.AUTO, 'gamescreen');
	this.game.state.add('Preload', Game.Preload);
	this.game.state.add('Titlescreen', Game.Titlescreen);
	this.game.state.add('Lvlselect', Game.Lvlselect);
	this.game.state.add('ActualGame', Game.ActualGame);
	this.game.state.start('Preload');
</script>
<% end %>